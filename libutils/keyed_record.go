// BSD 2-Clause License
//
// Copyright (c) 2018-2019 Don Owens <don@regexguy.com>.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package libutils

import (
    "fmt"
)

type KeyedRecordEncoder interface {
    // Joins the key and value bytes, returning the serialized record.
    JoinKV(key []byte, val []byte) ([]byte, error)

    // Serializes the value data structure.
    MarshalVal(interface{}) ([]byte, error)

    // If this object also implements the `KeyedRecordDecoder` interface, and
    // the encoding is the same for both input and output, CodecSame() returns
    // true. Otherwise, it returns false.
    //
    // This allows for lazy encoding. That is, if the raw record bytes that were
    // read in do not need to change, they can be written back out as-is,
    // instead of actually re-encoding.
    CodecSame() bool
}

type KeyedRecordDecoder interface {
    // Splits the record, returning the key and the serialized value data
    // structure.
    SplitKV([]byte) ([]byte, []byte, error)

    // Deserializes the value.
    UnmarshalVal([]byte) (interface{}, error)
}

type KeyedRecordScanner interface {
    // Advances the scanner to the next record. It returns false when the scan
    // stops, either by reaching the end of the input or an error.
    Scan() bool

    // Returns the most recent serialized record generated by a call to Scan().
    Record() (*KeyedRecord)

    // Returns the first non-EOF error that was encountered by the Scanner.
    Err() error
}

type KeyedRecordWriter interface {
    // Writes the entire seralized record.
    Write(*KeyedRecord) (int, error)
}

// KeyedRecord in this package supports the concept of records that consist of a
// (string) key and a (possible complex) value, along with lazy marshaling and
// unmarshaling of data.
//
// Extracting records from files is considered separate from the records
// themselves. E.g., records might live in a tab-delimited file where each
// record is stored as a key and a JSON object separated by a tab character,
// with a newline character delimiting records, like so:
//
//   foo[tab]{"on": true}[newline]
//   bar[tab]{"on": false}[newline]
//
// In this case, the newline is not part of the record. The KeyedRecordScanner
// and KeyedRecordWriter interfaces deal with reading and writing records. A
// KeyedRecord needs an decoder (KeyedRecordDecoder) in order to parse a record
// provided to it as a slice of bytes, and an encoder (KeyedRecordEncoder) to
// serialize the record to be written out. This allows for readily changing the
// output format, e.g., to variable integer length-prefixed records.
type KeyedRecord struct {
    wire_data_in []byte
    key []byte
    val_bytes_in []byte
    val_struct interface{}
    has_wire_data_in bool
    has_key bool
    has_val_bytes_in bool
    has_val_struct bool

    decoder KeyedRecordDecoder
    encoder KeyedRecordEncoder
}


// Mark the KeyedRecord dirty such that will reserialize the value data
// structure even if the encoder and encoder are the same and
// encoder.CodecSame() returns true.
func (kr *KeyedRecord) MarkDirty() {
    kr.has_wire_data_in = false
    kr.has_val_bytes_in = false
}

// Parse the raw record from wire data, using the provided decoder. The decoder
// is stored internally for later use.
func NewKeyedRecordFromBytes(raw_rec_bytes []byte,
    decoder KeyedRecordDecoder) (*KeyedRecord) {
    kr := new(KeyedRecord)
    kr.wire_data_in = raw_rec_bytes
    kr.has_wire_data_in = true
    kr.decoder = decoder

    return kr
}

// Create a new KeyedRecord object from a key and value.
func NewKeyedRecordFromKeyVal(key []byte, val interface{}) (*KeyedRecord) {
    kr := new(KeyedRecord)
    kr.key = key
    kr.has_key = true
    kr.val_struct = val
    kr.has_val_struct = true

    return kr
}

// Set the decoder object within the KeyedRecord for later use.
func (kr *KeyedRecord) SetDecoder(dec KeyedRecordDecoder) {
    kr.decoder = dec
}

// Set the encoder object within the KeyedRecord for later use.
func (kr *KeyedRecord) SetEncoder(enc KeyedRecordEncoder) {
    kr.encoder = enc
}

// Parse out the key from the record (if necessary) and return it.
func (kr *KeyedRecord) Key() ([]byte, error) {
    if kr == nil {
        return nil, fmt.Errorf("nil *KeyedRecord in Key()")
    }
    if ! kr.has_key {
        err := kr.decode_in_bytes()
        if err != nil {
            return nil, err
        }
    }
    return kr.key, nil
}

func (kr *KeyedRecord) decode_in_bytes() error {
    if ! kr.has_wire_data_in {
        return fmt.Errorf("no raw data to parse key/val from")
    }
    if kr.decoder == nil {
        return fmt.Errorf("no decoder to use to parse out key/val")
    }
    k, v, err := kr.decoder.SplitKV(kr.wire_data_in)
    if err != nil {
        return fmt.Errorf("couldn't decode raw bytes: %s", err)
    }
    kr.key = k
    kr.has_key = true
    kr.val_bytes_in = v
    kr.has_val_bytes_in = true

    return nil
}

// Parse out the key from the record (if necessary) and return it as a string.
func (kr *KeyedRecord) KeyString() (string, error) {
    key, err := kr.Key()
    return string(key), err
}

// Return the value of from the record as an interface{}. If you know what type
// the value should have, you can use an assertion to get to the underlying
// type, e.g.,
//
//   val, ok := kr.Val().(*MyStruct)
func (kr *KeyedRecord) Val() (interface{}, error) {
    if kr.has_val_struct {
        return kr.val_struct, nil
    }
    if ! kr.has_val_bytes_in {
        err := kr.decode_in_bytes()
        if err != nil {
            return nil, err
        }
    }
    val_struct, err := kr.decoder.UnmarshalVal(kr.val_bytes_in)
    if err != nil {
        return nil, fmt.Errorf("couldn't unmarshal value bytes: %s", err)
    }

    kr.val_struct = val_struct
    kr.has_val_struct = true

    return kr.val_struct, nil
}

// Parse out (if necessary) the key and value, returning both.
func (kr *KeyedRecord) KeyVal() ([]byte, interface{}, error) {
    if kr == nil {
        return nil, nil, fmt.Errorf("nil *KeyedRecord in KeyVal()")
    }

    k, err := kr.Key()
    if err != nil {
        return nil, nil, fmt.Errorf("couldn't parse key: %s", err)
    }
    v, err := kr.Val()
    if err != nil {
        return nil, nil, fmt.Errorf("couldn't decode value: %s", err)
    }

    return k, v, nil
}

// Serialize the record into a slice of bytes using the provided encoder.
func (kr *KeyedRecord) RecordBytesOut(encoder KeyedRecordEncoder) ([]byte, error) {
    if kr == nil {
        return nil, fmt.Errorf("nil *KeyedRecord in RecordBytesOut()")
    }

    if encoder == nil {
        encoder = kr.encoder
    }
    if encoder == nil {
        return nil, fmt.Errorf("no encoder set")
    }

    if kr.has_wire_data_in && kr.decoder != nil && encoder.CodecSame() {
        if codec, ok := kr.decoder.(KeyedRecordEncoder); ok {
            if codec == encoder {
                // encoder and decoder are the same object, and it also
                // specifies that we don't need to reserialize the data
                // structure.
                return kr.wire_data_in, nil
            }
        }
    }

    k, v, err := kr.KeyVal()
    if err != nil {
        return nil, err
    }

    val_bytes, err := encoder.MarshalVal(v)
    if err != nil {
        return nil, err
    }

    return encoder.JoinKV(k, val_bytes)
}
